import { GetNftTicketDetailDto, TokenPayloadDto } from '../dto';
import { GetTicketsByUserDto } from '../dto/get-ticket-inventory.dto';
import { Repository } from 'typeorm';
import { Event, OrganizerDetail, TicketSaleTransaction, TicketTier, User, NftTicket, BlockchainSnapshot } from '../entities';
import { TicketSaleStatus } from '../entities/ticket-sale-transaction.entity';
import { SearchResaleTicketDto } from '../dto/search-resale-ticket.dto';
import { GetTicketsByTierDto } from '../dto/search-ticket.dto';
import { GetResaleTicketDto } from '../dto/get-resale-ticket.dto';
export declare class NftTicketsService {
    private readonly nftTicketRepository;
    private readonly userRepository;
    private readonly eventRepository;
    private readonly ticketSaleTransactionRepository;
    private readonly organizerDetailnRepository;
    private readonly ticketTierRepository;
    private readonly blockchainSnapshotRepository;
    constructor(nftTicketRepository: Repository<NftTicket>, userRepository: Repository<User>, eventRepository: Repository<Event>, ticketSaleTransactionRepository: Repository<TicketSaleTransaction>, organizerDetailnRepository: Repository<OrganizerDetail>, ticketTierRepository: Repository<TicketTier>, blockchainSnapshotRepository: Repository<BlockchainSnapshot>);
    getNftTicketsByUser({ userId }: TokenPayloadDto, { limit, page, sortType, value, }: GetTicketsByUserDto): Promise<{
        tickets: any[];
        totalPages: number;
    }>;
    getResaleTicket(eventId: string, { limit, page }: GetResaleTicketDto): Promise<{
        event: {
            organizer: User;
            location: {
                latitude: number;
                longitude: number;
                locationName: string;
            };
            ticketTiers: {
                name: string;
                id: any;
                tickets: any[];
            }[];
            onChainId: number;
            transactionHash: string;
            thumbnailUrl: string;
            coverPhotoUrl: string;
            name: string;
            venue: string;
            sellStartDate: Date;
            sellEndDate: Date;
            eventStartDate: Date;
            eventEndDate: Date;
            description: string;
            status: import("../entities/event.entity").EventStatus;
            seatmapUrl: string;
            eventMetadataUrl: string;
            ticketMetadataUrl: string;
            searchVector: string;
            ticketAddress: string;
            maxPerUser: number;
            artistClasses: import("../entities").ArtistClass[];
            actionsLogs: import("../entities").ActionLog[];
            id: string;
            createdAt: Date;
            updatedAt: Date;
        };
    }>;
    checkTicketMintStatus(transaction_hash: string): Promise<TicketSaleStatus.PENDING | import("../entities/blockchain-snapshot.entity").BlockchainSnapshotStatus>;
    getTicketsByTier(eventId: string, getTicketsDto: GetTicketsByTierDto): Promise<{
        tickets: any[];
        totalPages: number;
    }>;
    getResaleTicketByPrice({ page, limit, minPrice, maxPrice, }: SearchResaleTicketDto): Promise<{
        result: any[];
        totalPages: number;
    }>;
    getNftTicketDetails({ userId }: TokenPayloadDto, { nftTicketId }: GetNftTicketDetailDto): Promise<{
        event: {
            id: string;
            name: string;
            description: string;
            eventStartDate: Date;
            eventEndDate: Date;
            sellStartDate: Date;
            sellEndDate: Date;
            thumbnailUrl: string;
            coverPhotoUrl: string;
            venue: string;
            seatmapUrl: string;
            maxPerUser: number;
            onchainId: number;
            ticketAddress: string;
            transactionHash: string;
            location: {
                latitude: number;
                longitude: number;
                locationName: string;
            };
        };
        organizer: User;
        ticketTier: {
            id: string;
            name: string;
            price: number;
            totalSupply: number;
            availableSupply: number;
            minResalePrice: number;
            maxResalePrice: number;
            royaltyPercentage: number;
            tierIndex: number;
            description: string;
        };
        nftTicket: {
            id: string;
            owner: User;
            quantity: number;
        };
    }>;
    getResaleTicketDetails(tierId: string): Promise<{
        [x: number]: any;
        length: number;
        toString(): string;
        toLocaleString(): string;
        toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions & Intl.DateTimeFormatOptions): string;
        pop(): any;
        push(...items: any[]): number;
        concat(...items: ConcatArray<any>[]): any[];
        concat(...items: any[]): any[];
        join(separator?: string): string;
        reverse(): any[];
        shift(): any;
        slice(start?: number, end?: number): any[];
        sort(compareFn?: ((a: any, b: any) => number) | undefined): any[];
        splice(start: number, deleteCount?: number): any[];
        splice(start: number, deleteCount: number, ...items: any[]): any[];
        unshift(...items: any[]): number;
        indexOf(searchElement: any, fromIndex?: number): number;
        lastIndexOf(searchElement: any, fromIndex?: number): number;
        every<S extends any>(predicate: (value: any, index: number, array: any[]) => value is S, thisArg?: any): this is S[];
        every(predicate: (value: any, index: number, array: any[]) => unknown, thisArg?: any): boolean;
        some(predicate: (value: any, index: number, array: any[]) => unknown, thisArg?: any): boolean;
        forEach(callbackfn: (value: any, index: number, array: any[]) => void, thisArg?: any): void;
        map<U>(callbackfn: (value: any, index: number, array: any[]) => U, thisArg?: any): U[];
        filter<S extends any>(predicate: (value: any, index: number, array: any[]) => value is S, thisArg?: any): S[];
        filter(predicate: (value: any, index: number, array: any[]) => unknown, thisArg?: any): any[];
        reduce(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any): any;
        reduce(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any, initialValue: any): any;
        reduce<U>(callbackfn: (previousValue: U, currentValue: any, currentIndex: number, array: any[]) => U, initialValue: U): U;
        reduceRight(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any): any;
        reduceRight(callbackfn: (previousValue: any, currentValue: any, currentIndex: number, array: any[]) => any, initialValue: any): any;
        reduceRight<U>(callbackfn: (previousValue: U, currentValue: any, currentIndex: number, array: any[]) => U, initialValue: U): U;
        find<S extends any>(predicate: (value: any, index: number, obj: any[]) => value is S, thisArg?: any): S | undefined;
        find(predicate: (value: any, index: number, obj: any[]) => unknown, thisArg?: any): any;
        findIndex(predicate: (value: any, index: number, obj: any[]) => unknown, thisArg?: any): number;
        fill(value: any, start?: number, end?: number): any[];
        copyWithin(target: number, start: number, end?: number): any[];
        entries(): ArrayIterator<[number, any]>;
        keys(): ArrayIterator<number>;
        values(): ArrayIterator<any>;
        includes(searchElement: any, fromIndex?: number): boolean;
        flatMap<U, This = undefined>(callback: (this: This, value: any, index: number, array: any[]) => U | readonly U[], thisArg?: This | undefined): U[];
        flat<A, D extends number = 1>(this: A, depth?: D | undefined): FlatArray<A, D>[];
        at(index: number): any;
        findLast<S extends any>(predicate: (value: any, index: number, array: any[]) => value is S, thisArg?: any): S | undefined;
        findLast(predicate: (value: any, index: number, array: any[]) => unknown, thisArg?: any): any;
        findLastIndex(predicate: (value: any, index: number, array: any[]) => unknown, thisArg?: any): number;
        toReversed(): any[];
        toSorted(compareFn?: ((a: any, b: any) => number) | undefined): any[];
        toSpliced(start: number, deleteCount: number, ...items: any[]): any[];
        toSpliced(start: number, deleteCount?: number): any[];
        with(index: number, value: any): any[];
        [Symbol.iterator](): ArrayIterator<any>;
        [Symbol.unscopables]: {
            [x: number]: boolean | undefined;
            length?: boolean | undefined;
            toString?: boolean | undefined;
            toLocaleString?: boolean | undefined;
            pop?: boolean | undefined;
            push?: boolean | undefined;
            concat?: boolean | undefined;
            join?: boolean | undefined;
            reverse?: boolean | undefined;
            shift?: boolean | undefined;
            slice?: boolean | undefined;
            sort?: boolean | undefined;
            splice?: boolean | undefined;
            unshift?: boolean | undefined;
            indexOf?: boolean | undefined;
            lastIndexOf?: boolean | undefined;
            every?: boolean | undefined;
            some?: boolean | undefined;
            forEach?: boolean | undefined;
            map?: boolean | undefined;
            filter?: boolean | undefined;
            reduce?: boolean | undefined;
            reduceRight?: boolean | undefined;
            find?: boolean | undefined;
            findIndex?: boolean | undefined;
            fill?: boolean | undefined;
            copyWithin?: boolean | undefined;
            entries?: boolean | undefined;
            keys?: boolean | undefined;
            values?: boolean | undefined;
            includes?: boolean | undefined;
            flatMap?: boolean | undefined;
            flat?: boolean | undefined;
            at?: boolean | undefined;
            findLast?: boolean | undefined;
            findLastIndex?: boolean | undefined;
            toReversed?: boolean | undefined;
            toSorted?: boolean | undefined;
            toSpliced?: boolean | undefined;
            with?: boolean | undefined;
            [Symbol.iterator]?: boolean | undefined;
            readonly [Symbol.unscopables]?: boolean | undefined;
        };
    }>;
}
